Index: src/IntegralTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\nimport acm.program.CommandLineProgram;\r\n\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * @author jmgimeno\r\n */\r\npublic class IntegralTypes extends CommandLineProgram {\r\n\r\n    public int BYTE_SIZE = 8;\r\n    public int SHORT_SIZE = 16;\r\n    public int INTEGER_SIZE = 32;\r\n    public int LONG_SIZE = 64;\r\n\r\n    // Creation methods (zero bytes)\r\n\r\n    public int[] zeroOfSize(int size) {\r\n        return new int[size];\r\n    }\r\n\r\n    public int[] zeroByte() {\r\n        return zeroOfSize(BYTE_SIZE);\r\n    }\r\n\r\n    public int[] zeroShort() {\r\n        return zeroOfSize(SHORT_SIZE);\r\n    }\r\n\r\n    public int[] zeroInteger() {\r\n        return zeroOfSize(INTEGER_SIZE);\r\n    }\r\n\r\n    public int[] zeroLong() {\r\n        return zeroOfSize(LONG_SIZE);\r\n    }\r\n\r\n    // toString\r\n\r\n    public String toString(int[] num) {\r\n        char[] chars = new char[num.length + num.length / 8];\r\n        int iChars = 0;\r\n        for (int iNum = num.length - 1; iNum >= 0; iNum--) {\r\n            chars[iChars] = (char) ('0' + num[iNum]);\r\n            iChars = iChars + 1;\r\n            if (iNum != 0 && iNum % 8 == 0) {\r\n                chars[iChars] = ' ';\r\n                iChars = iChars + 1;\r\n            }\r\n        }\r\n        return new String(chars, 0, iChars);\r\n    }\r\n\r\n    // Classifier methods\r\n\r\n    public boolean allBits(int[] num) {\r\n        for (int i : num) {\r\n            if (i != 0 && i != 1) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean hasSize(int[] num, int size) {\r\n        return num.length == size;\r\n    }\r\n\r\n    public boolean isByte(int[] num) {\r\n        return hasSize(num, BYTE_SIZE) && allBits(num);\r\n    }\r\n\r\n    public boolean isShort(int[] num) {\r\n        return hasSize(num, SHORT_SIZE) && allBits(num);\r\n    }\r\n\r\n    public boolean isInteger(int[] num) {\r\n        return hasSize(num, INTEGER_SIZE) && allBits(num);\r\n    }\r\n\r\n    public boolean isLong(int[] num) {\r\n        return hasSize(num, LONG_SIZE) && allBits(num);\r\n    }\r\n\r\n\r\n    // Creation methods from String (only takes into account correct bits)\r\n\r\n    public void copy(String from, int[] to) {\r\n        int iArray = 0;\r\n        for (int iString = from.length() - 1; iString >= 0 && iArray < to.length; iString--) {\r\n            if (from.charAt(iString) == '0' || from.charAt(iString) == '1') {\r\n                to[iArray] = (int) from.charAt(iString) - '0';\r\n                iArray += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    public int[] newByte(String from) {\r\n        int[] num = zeroByte();\r\n        copy(from, num);\r\n        return num;\r\n    }\r\n\r\n    public int[] newShort(String from) {\r\n        int[] num = zeroShort();\r\n        copy(from, num);\r\n        return num;\r\n    }\r\n\r\n    public int[] newInteger(String from) {\r\n        int[] num = zeroInteger();\r\n        copy(from, num);\r\n        return num;\r\n    }\r\n\r\n    public int[] newLong(String from) {\r\n        int[] num = zeroLong();\r\n        copy(from, num);\r\n        return num;\r\n    }\r\n\r\n    // Narrow\r\n\r\n    public int[] narrow(int[] from, int toLength) {\r\n        int[] narrowed = zeroOfSize(toLength);\r\n        copy(toString(from),narrowed);\r\n        return narrowed;\r\n    }\r\n\r\n    // Widen\r\n\r\n\r\n    public int[] widen(int[] from, int toLength) {\r\n        int[] widened = zeroOfSize(toLength);\r\n        copy(toString(from),widened);\r\n        if (from.length > 0) {\r\n            fillWithSign(widened,from.length - 1);\r\n        }\r\n        return widened;\r\n    }\r\n\r\n    //Auxiliary function fillWithSign\r\n\r\n    public void fillWithSign(int[] num, int signPosition){\r\n        for( int i = signPosition + 1; i < num.length; i++){\r\n            num[i] = num[signPosition];\r\n        }\r\n    }\r\n\r\n    // Cast\r\n\r\n    public int[] cast(int[] from, int toLength) {\r\n        if (from.length < toLength) {\r\n            return widen(from, toLength);\r\n        } else {\r\n            return narrow(from, toLength);\r\n        }\r\n    }\r\n\r\n    public int[] toByte(int[] from) {\r\n        return cast(from, BYTE_SIZE);\r\n    }\r\n\r\n    public int[] toShort(int[] from) {\r\n        return cast(from, SHORT_SIZE);\r\n    }\r\n\r\n    public int[] toInteger(int[] from) {\r\n        return cast(from, INTEGER_SIZE);\r\n    }\r\n\r\n    public int[] toLong(int[] from) {\r\n        return cast(from, LONG_SIZE);\r\n    }\r\n\r\n    // And &\r\n\r\n    public int[] and(int[] arg1, int[] arg2) {\r\n        int resultSize = chooseLength(arg1,arg2);\r\n        int[] wideArg1 = widen(arg1,resultSize), wideArg2 = widen(arg2,resultSize);\r\n        int[] result = zeroOfSize(resultSize);\r\n        for (int i = 0; i < resultSize; i++) {\r\n            if (wideArg1[i] == 1 && wideArg2[i] == 1) {\r\n                result[i] = 1;\r\n            } else {\r\n                result[i] = 0;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //Auxiliary function: chooseLength (2 parameters)\r\n\r\n    public int chooseLength (int[] num1, int[] num2){\r\n        if(isLong(num1) || isLong(num2)){\r\n            return LONG_SIZE;\r\n        }\r\n        return INTEGER_SIZE;\r\n    }\r\n\r\n    // Or |\r\n\r\n    public int[] or(int[] arg1, int[] arg2) {\r\n        int resultSize = chooseLength(arg1,arg2);\r\n        int[] wideArg1 = widen(arg1,resultSize), wideArg2 = widen(arg2,resultSize);\r\n        int[] result = zeroOfSize(resultSize);\r\n        for (int i = 0; i < resultSize; i++) {\r\n            if (wideArg1[i] == 0 && wideArg2[i] == 0) {\r\n                result[i] = 0;\r\n            } else {\r\n                result[i] = 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Left shift <<\r\n\r\n    public int[] leftShift(int[] num, int numPos) {\r\n        int resultSize = chooseLength(num);\r\n        int[] wideNum = widen(num,resultSize);\r\n        int[] result = zeroOfSize(resultSize);\r\n        int distance = numPos % resultSize;\r\n        for (int i = 0; i < resultSize - distance; i++) {\r\n            result[i + distance] = wideNum[i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //Auxiliary function: chooseLength (1 parameter)\r\n    public int chooseLength (int[] num1){\r\n        if(isLong(num1)){\r\n            return LONG_SIZE;\r\n        }\r\n        return INTEGER_SIZE;\r\n    }\r\n\r\n    // Unsigned right shift >>>\r\n\r\n    public int[] unsignedRightShift(int[] num, int numPos) {\r\n        int resultSize = chooseLength(num);\r\n        int[] wideNum = widen(num,resultSize);\r\n        int[] result = zeroOfSize(resultSize);\r\n        int distance = numPos % resultSize;\r\n        shiftRight(wideNum,result,distance);\r\n        return result;\r\n    }\r\n\r\n    public void shiftRight (int[] from, int[] to, int distance){\r\n        for (int i = distance; i < to.length; i++) {\r\n            to[i - distance] = from[i];\r\n        }\r\n    }\r\n\r\n    // Signed right shift >>\r\n\r\n    public int[] signedRightShift(int[] num, int numPos) {\r\n        int resultSize = chooseLength(num);\r\n        int[] wideNum = widen(num,resultSize);\r\n        int[] result = zeroOfSize(resultSize);\r\n        int distance = numPos % resultSize;\r\n        shiftRight(wideNum,result,distance);\r\n        fillWithSign(result,(resultSize - distance) - 1);\r\n        return result;\r\n    }\r\n\r\n    /**********************************************************************\r\n     * TESTING\r\n     **********************************************************************/\r\n\r\n    public void run() {\r\n        testToString();\r\n        testAllBits();\r\n        testCopy();\r\n        testNarrow();\r\n        testWiden();\r\n        testCast();\r\n        testAnd();\r\n        testOr();\r\n        testLeftShift();\r\n        testUnsignedRightShift();\r\n        testSignedRightShift();\r\n    }\r\n\r\n    // Test functions\r\n\r\n    public void testToString() {\r\n        checkToString(\"00000000\",\r\n                \"toString(zeroByte())\",\r\n                zeroByte());\r\n        checkToString(\"00000000 00000000\",\r\n                \"toString(zeroShort())\",\r\n                zeroShort());\r\n        checkToString(\"00000000 00000000 00000000 00000000\",\r\n                \"toString(zeroInteger())\",\r\n                zeroInteger());\r\n        checkToString(\"00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\",\r\n                \"toString(zeroLong())\",\r\n                zeroLong());\r\n        checkToString(\"10 11001010\",\r\n                \"toString(new int[]{0, 1, 0, 1, 0, 0, 1, 1, 0, 1})\",\r\n                new int[]{0, 1, 0, 1, 0, 0, 1, 1, 0, 1});\r\n        printBar();\r\n    }\r\n\r\n    public void testAllBits() {\r\n        checkTrue(\"allBits(new int[] {0, 1, 0, 1, 1})\",\r\n                allBits(new int[]{0, 1, 0, 1, 1}));\r\n        checkTrue(\"allBits(new int[] {})\",\r\n                allBits(new int[]{}));\r\n        checkFalse(\"allBits(new int[] {1, 2, 0})\",\r\n                allBits(new int[]{1, 2, 0}));\r\n        printBar();\r\n    }\r\n\r\n    public void testCopy() {\r\n        checkCopy(new int[]{1, 1, 0, 0, 1},\r\n                \"10011\",\r\n                5);\r\n        checkCopy(new int[]{1, 1, 0},\r\n                \"10011\",\r\n                3);\r\n        checkCopy(new int[]{1, 1, 0, 0, 1, 0, 0},\r\n                \"10011\",\r\n                7);\r\n        checkCopy(new int[]{0, 0, 0},\r\n                \"\",\r\n                3);\r\n        checkCopy(new int[]{},\r\n                \"10011\",\r\n                0);\r\n        checkCopy(new int[]{1, 1, 0, 0, 1, 0},\r\n                \"12050811\",\r\n                6);\r\n        printBar();\r\n    }\r\n\r\n    public void testNarrow() {\r\n        checkNarrow(\"10011\", \"10011\", 5);\r\n        checkNarrow(\"011\", \"10011\", 3);\r\n        checkNarrow(\"\", \"10011\", 0);\r\n        checkNarrowIsCopy();\r\n        printBar();\r\n    }\r\n\r\n    public void testWiden() {\r\n        checkWiden(\"000101\", \"0101\", 6);\r\n        checkWiden(\"111010\", \"1010\", 6);\r\n        checkWiden(\"0000\", \"\", 4);\r\n        checkWidenIsCopy();\r\n        printBar();\r\n    }\r\n\r\n    private void testCast() {\r\n        checkCast(\"01\", \"0101\", 2);\r\n        checkCast(\"000101\", \"0101\", 6);\r\n        checkCast(\"11\", \"1111\", 2);\r\n        checkCast(\"111111\", \"1111\", 6);\r\n        checkCast(\"000000\", \"\", 6);\r\n        checkCast(\"\", \"1111\", 0);\r\n        checkCastIsCopy();\r\n        printBar();\r\n    }\r\n\r\n    private void testAnd() {\r\n        checkAnd(newInteger(\"00000000 00000000 00000000 00100111\"),\r\n                newByte(\"01110111\"),\r\n                newByte(\"00100111\"));\r\n        checkAnd(newInteger(\"00000000 00000000 00000000 00100111\"),\r\n                newByte(\"01110111\"),\r\n                newByte(\"10100111\"));\r\n        checkAnd(newInteger(\"00000000 00000000 00000000 00100111\"),\r\n                newByte(\"11110111\"),\r\n                newByte(\"00100111\"));\r\n        checkAnd(newInteger(\"11111111 11111111 11111111 10100111\"),\r\n                newByte(\"11110111\"),\r\n                newByte(\"10100111\"));\r\n        checkAnd(newInteger(\"11111111 11111111 11111111 10100111\"),\r\n                newByte(\"11110111\"),\r\n                newByte(\"10100111\"));\r\n\r\n        checkAnd(newInteger(\"11111111 11111111 11111100 10100111\"),\r\n                newShort(\"11111100 11110111\"),\r\n                newByte(\"10100111\"));\r\n\r\n        checkAnd(newLong(\"11111111 00000000 11111111 00000000 11111111 00000000 11111100 10100111\"),\r\n                newLong(\"11111111 00000000 11111111 00000000 11111111 00000000 11111100 11110111\"),\r\n                newByte(\"10100111\"));\r\n        printBar();\r\n    }\r\n\r\n    private void testOr() {\r\n        checkOr(newInteger(\"00000000 00000000 00000000 01110111\"),\r\n                newByte(\"01110111\"),\r\n                newByte(\"00100111\"));\r\n        checkOr(newInteger(\"11111111 11111111 11111111 11110111\"),\r\n                newByte(\"01110111\"),\r\n                newByte(\"10100111\"));\r\n        checkOr(newInteger(\"11111111 11111111 11111111 11110111\"),\r\n                newByte(\"11110111\"),\r\n                newByte(\"00100111\"));\r\n        checkOr(newInteger(\"11111111 11111111 11111111 11110111\"),\r\n                newByte(\"11110111\"),\r\n                newByte(\"10100111\"));\r\n        checkOr(newInteger(\"11111111 11111111 11111111 11110111\"),\r\n                newByte(\"11110111\"),\r\n                newByte(\"10100111\"));\r\n\r\n        checkOr(newInteger(\"11111111 11111111 11111111 11110111\"),\r\n                newShort(\"11111100 11110111\"),\r\n                newByte(\"10100111\"));\r\n\r\n        checkOr(newLong(\"11111111 00000000 11111111 00000000 11111111 00000000 11111100 11110111\"), newLong(\"11111111 00000000 11111111 00000000 11111111 00000000 11111100 11110111\"),\r\n                newByte(\"00100111\"));\r\n        printBar();\r\n    }\r\n\r\n    public void testLeftShift() {\r\n        checkLeftShift(newInteger(\"00000000 00000000 00000000 00110101\"),\r\n                newByte(\"00110101\"),\r\n                0);\r\n        checkLeftShift(newInteger(\"00000000 00000000 00000110 10100000\"),\r\n                newByte(\"00110101\"),\r\n                5);\r\n        checkLeftShift(newInteger(\"11111111 11111111 11110110 10100000\"),\r\n                newByte(\"10110101\"),\r\n                5);\r\n        checkLeftShift(newInteger(\"11111111 11111111 11110110 10100000\"),\r\n                newByte(\"10110101\"),\r\n                69);\r\n        checkLeftShift(newInteger(\"00000000 00100110 01011010 10000000\"),\r\n                newShort(\"01001100 10110101\"),\r\n                7);\r\n\r\n        checkLeftShift(newLong(\"10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\"),\r\n                newLong(\"11111111 00000000 11111111 00000000 11111111 00000000 11111100 11110111\"),\r\n                63);\r\n        checkLeftShiftIsCopy();\r\n        printBar();\r\n    }\r\n\r\n    private void testUnsignedRightShift() {\r\n        checkUnsignedRightShift(newInteger(\"00000000 00000000 00000000 00110101\"),\r\n                newByte(\"00110101\"),\r\n                0);\r\n        checkUnsignedRightShift(newInteger(\"00000000 00000000 00000000 00000001\"),\r\n                newByte(\"00110101\"),\r\n                5);\r\n        checkUnsignedRightShift(newInteger(\"00000111 11111111 11111111 11111101\"),\r\n                newByte(\"10110101\"),\r\n                5);\r\n        checkUnsignedRightShift(newInteger(\"00000111 11111111 11111111 11111101\"),\r\n                newByte(\"10110101\"),\r\n                69);\r\n        checkUnsignedRightShift(newInteger(\"00000000 00000000 00000000 10011001\"),\r\n                newShort(\"01001100 10110101\"),\r\n                7);\r\n\r\n        checkUnsignedRightShift(newLong(\"00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001\"),\r\n                newLong(\"11111111 00000000 11111111 00000000 11111111 00000000 11111100 11110111\"),\r\n                63);\r\n        checkUnsignedRightShiftIsCopy();\r\n        printBar();\r\n    }\r\n\r\n    private void testSignedRightShift() {\r\n        checkSignedRightShift(newInteger(\"00000000 00000000 00000000 00110101\"),\r\n                newByte(\"00110101\"),\r\n                0);\r\n        checkSignedRightShift(newInteger(\"00000000 00000000 00000000 00000001\"),\r\n                newByte(\"00110101\"),\r\n                5);\r\n        checkSignedRightShift(newInteger(\"11111111 11111111 11111111 11111101\"),\r\n                newByte(\"10110101\"),\r\n                5);\r\n        checkSignedRightShift(newInteger(\"11111111 11111111 11111111 11111101\"),\r\n                newByte(\"10110101\"),\r\n                69);\r\n        checkSignedRightShift(newInteger(\"00000000 00000000 00000000 10011001\"),\r\n                newShort(\"01001100 10110101\"),\r\n                7);\r\n\r\n        checkSignedRightShift(newLong(\"11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111\"),\r\n                newLong(\"11111111 00000000 11111111 00000000 11111111 00000000 11111100 11110111\"),\r\n                63);\r\n        checkSignedRightShiftIsCopy();\r\n        printBar();\r\n    }\r\n\r\n    // Checking functions\r\n\r\n    public void checkToString(String expected, String expression, int[] num) {\r\n        String actual = toString(num);\r\n        if (expected.equals(actual)) {\r\n            printlnOk(expression);\r\n        } else {\r\n            printlnError(\"\\\"\" + expression + \"\\\" should be \\\"\" + expected + \"\\\" but is \\\"\" + actual + \"\\\"\");\r\n        }\r\n    }\r\n\r\n    public void checkBoolean(boolean expected, String expression, boolean actual) {\r\n        if (expected == actual) {\r\n            printlnOk(expression);\r\n        } else {\r\n            printlnError(\"\\\"\" + expression + \"\\\" should be \" + expected);\r\n        }\r\n    }\r\n\r\n    public void checkTrue(String expression, boolean actual) {\r\n        checkBoolean(true, expression, actual);\r\n    }\r\n\r\n    public void checkFalse(String expression, boolean actual) {\r\n        checkBoolean(false, expression, actual);\r\n    }\r\n\r\n    private void checkCopy(int[] expected, String from, int arraySize) {\r\n        String expression = \"copy(\\\"\" + from + \"\\\", array of length \" + arraySize + \")\";\r\n        int[] actual = new int[arraySize];\r\n        copy(from, actual);\r\n        if (Arrays.equals(expected, actual)) {\r\n            printlnOk(expression);\r\n        } else {\r\n            printlnError(expression + \" should be \" + Arrays.toString(expected) + \" but is \" + Arrays.toString(actual));\r\n        }\r\n    }\r\n\r\n    private void checkNarrow(String expected, String fromString, int toLength) {\r\n        int[] from = zeroOfSize(fromString.length());\r\n        copy(fromString, from);\r\n        int[] actual = narrow(from, toLength);\r\n        String expression = \"narrow(\\\"\" + fromString + \"\\\", \" + toLength + \")\";\r\n        report(expected, expression, actual);\r\n    }\r\n\r\n    private void checkNarrowIsCopy() {\r\n        int[] from = new int[]{0, 1, 0};\r\n        int[] to = narrow(from, from.length);\r\n        checkIsCopy(\"Narrow\", from, to);\r\n    }\r\n\r\n    private void checkWiden(String expected, String fromString, int toLength) {\r\n        int[] from = zeroOfSize(fromString.length());\r\n        copy(fromString, from);\r\n        int[] actual = widen(from, toLength);\r\n        String expression = \"widen(\\\"\" + fromString + \"\\\", \" + toLength + \")\";\r\n        report(expected, expression, actual);\r\n    }\r\n\r\n    private void checkWidenIsCopy() {\r\n        int[] from = new int[]{0, 1, 0};\r\n        int[] to = widen(from, from.length);\r\n        checkIsCopy(\"Widen\", from, to);\r\n    }\r\n\r\n    private void checkCast(String expected, String fromString, int toLength) {\r\n        int[] from = zeroOfSize(fromString.length());\r\n        copy(fromString, from);\r\n        int[] actual = cast(from, toLength);\r\n        String expression = \"cast(\\\"\" + fromString + \"\\\", \" + toLength + \")\";\r\n        report(expected, expression, actual);\r\n    }\r\n\r\n    public void report(String expected, String expression, int[] actual) {\r\n        String actualString = toString(actual);\r\n        if (expected.equals(actualString)) {\r\n            printlnOk(expression);\r\n        } else {\r\n            printlnError(expression + \" should be \\\"\" + expected + \"\\\" but is \\\"\" + actualString + \"\\\"\");\r\n        }\r\n    }\r\n\r\n    private void checkCastIsCopy() {\r\n        int[] from = new int[]{0, 1, 0};\r\n        int[] to = cast(from, from.length);\r\n        checkIsCopy(\"Cast\", from, to);\r\n    }\r\n\r\n    public void checkIsCopy(String op, int[] from, int[] to) {\r\n        from[0] = 1 - from[0];\r\n        if (from[0] != to[0]) {\r\n            printlnOk(op + \" does copy and does not return the same\");\r\n        } else {\r\n            printlnError(op + \" should copy and not return the same\");\r\n        }\r\n    }\r\n\r\n    private void checkAnd(int[] expected, int[] arg1, int[] arg2) {\r\n        checkBinaryOp(expected, \"and\", arg1, arg2, and(arg1, arg2));\r\n    }\r\n\r\n    private void checkOr(int[] expected, int[] arg1, int[] arg2) {\r\n        checkBinaryOp(expected, \"or\", arg1, arg2, or(arg1, arg2));\r\n    }\r\n\r\n    private void checkBinaryOp(int[] expected, String op, int[] arg1, int[] arg2, int[] actual) {\r\n        String expression = op + \"(\\\"\" + toString(arg1) + \"\\\", \\\"\" + toString(arg2) + \"\\\")\";\r\n        report(expected, expression, actual);\r\n    }\r\n\r\n    public void report(int[] expected, String expression, int[] actual) {\r\n        if (Arrays.equals(expected, actual))\r\n            printlnOk(expression +\r\n                    \"\\n\\tis \\\"\" + toString(actual) + \"\\\"\");\r\n        else\r\n            printlnError(expression +\r\n                    \"\\n\\tshould be \\\"\" + toString(expected) +\r\n                    \"\\n\\tbut is    \\\"\" + toString(actual));\r\n    }\r\n\r\n    public void checkShift(int[] expected, String op, int[] num, int numPos, int[] actual) {\r\n        String expression = op + \"(\\\"\" + toString(num) + \"\\\", \" + numPos + \")\";\r\n        report(expected, expression, actual);\r\n    }\r\n\r\n    public void checkLeftShift(int[] expected, int[] num, int numPos) {\r\n        checkShift(expected, \"leftShift\", num, numPos, leftShift(num, numPos));\r\n    }\r\n\r\n    private void checkLeftShiftIsCopy() {\r\n        int[] num = zeroByte();\r\n        int[] result = leftShift(num, 0);\r\n        checkIsCopy(\"leftShift\", num, result);\r\n    }\r\n\r\n    public void checkUnsignedRightShift(int[] expected, int[] num, int numPos) {\r\n        checkShift(expected, \"unsignedRightShift\", num, numPos, unsignedRightShift(num, numPos));\r\n    }\r\n\r\n\r\n    private void checkUnsignedRightShiftIsCopy() {\r\n        int[] num = zeroByte();\r\n        int[] result = unsignedRightShift(num, 0);\r\n        checkIsCopy(\"unsignedRightShift\", num, result);\r\n    }\r\n\r\n    public void checkSignedRightShift(int[] expected, int[] num, int numPos) {\r\n        checkShift(expected, \"signedRightShift\", num, numPos, signedRightShift(num, numPos));\r\n    }\r\n\r\n\r\n    private void checkSignedRightShiftIsCopy() {\r\n        int[] num = zeroByte();\r\n        int[] result = signedRightShift(num, 0);\r\n        checkIsCopy(\"signedRightShift\", num, result);\r\n    }\r\n\r\n    // Colorize output for CommanLineProgram (visible in Netbeans Output)\r\n\r\n    public String ANSI_RESET = \"\\u001B[0m\";\r\n    public String ANSI_RED = \"\\u001B[31m\";\r\n    public String ANSI_GREEN = \"\\u001B[32m\";\r\n\r\n    public void printlnOk(String message) {\r\n        if (acm.program.CommandLineProgram.class.isInstance(this))\r\n            println(ANSI_GREEN + \"OK: \" + message + ANSI_RESET);\r\n        else\r\n            println(\"OK: \" + message);\r\n    }\r\n\r\n    public void printlnError(String message) {\r\n        if (acm.program.CommandLineProgram.class.isInstance(this))\r\n            println(ANSI_RED + \"ERROR: \" + message + ANSI_RESET);\r\n        else\r\n            println(\"ERROR: \" + message);\r\n    }\r\n\r\n    public void printBar() {\r\n        println(\"--------------------------------------------------\");\r\n    }\r\n\r\n    // Entry point to avoid problems in some platforms\r\n\r\n    public static void main(String[] args) {\r\n        new IntegralTypes().start(args);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/IntegralTypes.java b/src/IntegralTypes.java
--- a/src/IntegralTypes.java	(revision 1e905bda2a52269295ab491def2ce80ecca7a1d3)
+++ b/src/IntegralTypes.java	(date 1710063509394)
@@ -54,7 +54,7 @@
     // Classifier methods
 
     public boolean allBits(int[] num) {
-        for (int i : num) {
+        for (int i = ) {
             if (i != 0 && i != 1) {
                 return false;
             }
